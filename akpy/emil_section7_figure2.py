'''
Based on:
%Emil Bjornson, Jakob Hoydis and Luca Sanguinetti (2017),
%"Massive MIMO Networks: Spectral, Energy, and Hardware Efficiency",
%Foundations and Trends in Signal Processing: Vol. 11, No. 3-4,
%pp. 154-655. DOI: 10.1561/2000000093.
%https://www.massivemimobook.com

Reproduces part of section7_figure2.m, more specifically the equal power allocation as indicated in
ak_section7_figure2.m in folder D:\gits\lasse\software\mimo-toolbox\third_party\emil_massivemimobook\Code

This version uses randn.

The previous version synchronized with Matlab because the randn's were substituted by rand in both Python (here)
and Matlab. In Matlab we used use_rand_for_python = 1 in ak_functionChannelEstimates.m
Then the SE differ by at most 1e-6. For that, the same matrix R, generated by Matlab, are used (read from file).
'''
#in all reshapes I need to use 'F': h_temp = np.reshape(h_temp,(self.K,self.L),'F')

from akpy.matlab_tofrom_python import read_matlab_array_from_mat
#from .matlab_tofrom_python import read_matlab_array_from_mat
import numpy as np
from scipy.linalg import sqrtm
import matplotlib.pyplot as plt
import os
from akpy.util import compare_tensors

should_compare_with_Matlab = False #use True to use rand instead of randn

class ChannelEstimator:
    def __init__(self, discount=0.9):
        #Number of BSs
        self.L = 16
        #Number of UEs per BS
        self.K = 10
        #Number of BS antennas
        self.M = 64
        #Define the pilot reuse factor
        self.f = 2
        #Select the number of setups with random UE locations
        #nbrOfSetups = 100
        #Select the number of channel realizations per setup
        self.nbrOfRealizations = 100
        ## Propagation parameters
        #Communication bandwidth
        B = 20e6

        #Total uplink transmit power per UE (mW)
        self.p = 100

        #Total downlink transmit power per UE (mW)
        rho = 100

        #Maximum downlink transmit power per BS (mW)
        self.Pmax = self.K*rho

        #Compute downlink power per UE in case of equal power allocation
        self.rhoEqual = (self.Pmax/self.K)*np.ones((self.K,self.L))

        #Define noise figure at BS (in dB)
        noiseFigure = 7

        #Compute noise power
        noiseVariancedBm = -174 + 10*np.log10(B) + noiseFigure

        #Select length of coherence block
        self.tau_c = 200

        #Use the approximation of the Gaussian local scattering model
        accuracy = 2

        #Angular standard deviation in the local scattering model (in degrees)
        ASDdeg = 10
        if os.name == 'nt':
            fileName = 'D:/gits/lasse/software/mimo-toolbox/third_party/emil_massivemimobook/Code/R_channelGaindB.mat'
        else:
            fileName = '/mnt/d/gits/lasse/software/mimo-toolbox/third_party/emil_massivemimobook/Code/R_channelGaindB.mat'
        self.channelGaindB=read_matlab_array_from_mat(fileName, 'channelGaindB')
        self.R=read_matlab_array_from_mat(fileName, 'R') #normalized to have norm = M

        #print('R', self.R.shape)

        #Compute the normalized average channel gain, where the normalization
        #is based on the noise power
        channelGainOverNoise = self.channelGaindB - noiseVariancedBm

        self.channel_gain_over_noise_linear = 10**(channelGainOverNoise/10)

        #from functionChannelEstimates.m
        #Length of pilot sequences
        self.tau_p = self.f*self.K

        #Generate pilot pattern
        if self.f == 1:
            self.pilotPattern = np.ones((self.L,1))
        elif self.f == 2: #Only works in the running example with its 16 BSs
            self.pilotPattern = np.kron([[1,1]],[1, 2, 1, 2, 2, 1, 2, 1])
        elif self.f == 4: #Only works in the running example with its 16 BSs
            self.pilotPattern = np.kron([[1,1]],[1, 2, 1, 2, 3, 4, 3, 4])
        elif self.f == 16: #Only works in the running example with its 16 BSs
            self.pilotPattern = np.arange(1,self.L)

        print('Pilot groups=', self.pilotPattern)
        #Store identity matrix of size M x M
        self.eyeM = np.eye(self.M)


    '''
    From: section7_figure2.m
    '''
    def estimate_channels(self):
        #Compute the normalized average channel gain, where the normalization
        #is based on the noise power
        x=3

    '''
    Get self.nbrOfRealizations realizations of all channels.
    H is complex-valued 5-d tensor with dimension M x self.nbrOfRealizations x K x L x L.
    '''
    def channel_realizations(self):
        if should_compare_with_Matlab:
            H = np.random.rand(self.M,self.nbrOfRealizations,self.K,self.L,self.L) + \
                1j * np.random.rand(self.M,self.nbrOfRealizations,self.K,self.L,self.L)
            H = np.reshape(H.flatten(),H.shape,'F') #need to reorder to match Matlab
        else:
            #Go through all channels and apply the channel gains to the spatial
            H = np.random.randn(self.M,self.nbrOfRealizations,self.K,self.L,self.L) + \
                1j * np.random.randn(self.M,self.nbrOfRealizations,self.K,self.L,self.L)

        #if True:
        #    return H
        for j in range(self.L):
            for l in range(self.L):
                for k in range(self.K):
                    Rtemp = self.channel_gain_over_noise_linear[k,j,l] * self.R[:,:,k,j,l]
                    #print(Rtemp.shape)
                    #Rtemp=np.matrix([[8,1+3j,6],[3-100j,5,7],[4,9,2]])
                    Rsqrt= sqrtm(Rtemp)
                    #print(Rsqrt)
                    #exit(-1)
                    Htemp = H[:,:,k,j,l]
                    #Apply correlation to the uncorrelated channel realizations
                    H[:,:,k,j,l] = np.sqrt(0.5) * np.matmul(Rsqrt,Htemp)
        return H

    '''
    Linear MMSE channel estimator. From function ak_functionChannelEstimates.m
    Need to implement the EW-MMSE estimator and the LS estimator.
    '''
    def channel_estimates_mmse(self,H):
        if False:
            fileName = 'D:/gits/lasse/software/mimo-toolbox/third_party/emil_massivemimobook/Code/H_Np_R.mat'
            self.R=read_matlab_array_from_mat(fileName, 'R')
            H=read_matlab_array_from_mat(fileName, 'H')
            Np=read_matlab_array_from_mat(fileName, 'Np')
        else:
            if should_compare_with_Matlab:
                #Generate realizations of normalized noise
                Np = np.sqrt(0.5)*(np.random.rand(self.M,self.nbrOfRealizations,self.K,self.L,self.f) +
                    1j * np.random.rand(self.M,self.nbrOfRealizations,self.K,self.L,self.f) )
                Np = np.reshape(Np.flatten(),Np.shape,'F') #need to reorder to match Matlab
            else:
                #Generate realizations of normalized noise
                Np = np.sqrt(0.5)*(np.random.randn(self.M,self.nbrOfRealizations,self.K,self.L,self.f) +
                                   1j * np.random.randn(self.M,self.nbrOfRealizations,self.K,self.L,self.f) )
        #Prepare to store MMSE channel estimates
        Hhat_MMSE = np.zeros((self.M,self.nbrOfRealizations,self.K,self.L,self.L),dtype=np.complex64)
        #Prepare to store estimation error correlation matrices
        C_MMSE = np.zeros((self.M,self.M,self.K,self.L,self.L),dtype=np.complex64)
        #C_MMSE = np.zeros((self.M,self.M,self.K,self.L,self.L))  #real-valued

        #Go through all channels and apply the channel gains to the spatial
        #correlation matrices
        R_scaled = np.zeros(self.R.shape, dtype=np.complex64)
        for j in range(self.L):
            for l in range(self.L):
                for k in range(self.K):
                    if self.channelGaindB[k,j,l]>-np.Inf:
                        #Extract channel gain in linear scale
                        #channel_gain_linear = 10**(self.channelGaindB[k,j,l]/10)
                        #Apply channel gain to correlation matrix
                        R_scaled[:,:,k,j,l] = self.R[:,:,k,j,l] * self.channel_gain_over_noise_linear[k,j,l]
                        #R_scaled[:,:,k,j,l] = self.R[:,:,k,j,l] * channel_gain_linear
                    else:
                        R_scaled[:,:,k,j,l] = 0
                        H[:,:,k,j,l] = 0

        # Go through all cells
        for j in range(self.L):
            #Go through all f pilot groups
            for g in range(self.f):
                #Extract the cells that belong to pilot group g
                groupMembers = np.where(self.pilotPattern == g+1) #add 1 because first pilot group is 1
                groupMembers = groupMembers[1] #AK-TODO buggy, fix it, now need to discard 1st dimension
                #if not groupMembers.any():
                #    raise RuntimeError('No cell is assigned to pilot group = ', g+1)
                #Compute processed pilot signal for all UEs that use these pilots, according to (3.5)

                Htemp = H[:,:,:,groupMembers,j]
                yp = np.sqrt(self.p)*self.tau_p*np.sum(Htemp,3) + np.sqrt(self.tau_p)*Np[:,:,:,j,g]
                #Go through all UEs
                for k in range(self.K):
                    #Compute the matrix that is inverted in the MMSE estimator
                    Rtemp = R_scaled[:,:,k,groupMembers,j]
                    PsiInv = (self.p*self.tau_p*np.sum(Rtemp,2) + self.eyeM)
                    for l in groupMembers:
                        #Compute MMSE estimate of channel between BS l and UE k in
                        #cell j using (3.9) in Theorem 3.1
                        #x = B/A is the solution to the equation xA = B. mrdivide in Matlab
                        RPsi = np.matmul(R_scaled[:,:,k,l,j], np.linalg.inv(PsiInv))
                        Hhat_MMSE[:,:,k,l,j] = np.sqrt(self.p)*np.matmul(RPsi,yp[:,:,k])
                        #Compute corresponding estimation error correlation matrix, using (3.11)
                        C_MMSE[:,:,k,l,j] = R_scaled[:,:,k,l,j] - self.p*self.tau_p*np.matmul(RPsi,R_scaled[:,:,k,l,j])
        return Hhat_MMSE, C_MMSE


    '''
    from functionComputeSINR_DL.m
    Implements only the MMSE precoding (from MMSE combining and duality)
    '''
    def compute_SINR_DL_mmse_precoding(self, H, Hhat, C):
        if False:
            #fileName = 'D:/gits/lasse/software/mimo-toolbox/third_party/emil_massivemimobook/Code/H_Hhat_C.mat'
            fileName = '/mnt/d/gits/lasse/software/mimo-toolbox/third_party/emil_massivemimobook/Code/H_Hhat_C.mat'
            H=read_matlab_array_from_mat(fileName, 'H')
            Hhat=read_matlab_array_from_mat(fileName, 'Hhat')
            C=read_matlab_array_from_mat(fileName, 'C')

        #Store identity matrices of different sizes
        #eyeK = np.eye(self.K)
        eyeM = np.eye(self.M)
        
        #Compute sum of all estimation error correlation matrices at every BS
        C_totM = np.reshape(self.p*np.sum(np.sum(C,2),2),[self.M, self.M, self.L],'F')
        
        #Compute the prelog factor assuming only downlink transmission
        #prelogFactor = (self.tau_c-self.tau_p)/(self.tau_c)
        
        #Prepare to store simulation results for signal gains
        signal_MMMSE = np.zeros((self.K,self.L),dtype=np.complex64)
        
        #Prepare to store simulation results for Bernoulli_extra_interference powers
        #interf_MMMSE = np.zeros((self.K,self.L,self.K,self.L),dtype=np.complex64)
        interf_MMMSE = np.zeros((self.K,self.L,self.K,self.L)) #real-valued, not complex
        
        for n in range(self.nbrOfRealizations): #Go through all channel realizations
            #Go through all cells
            for j in range(self.L):
                #Extract channel realizations from all UEs to BS j
                Hallj = np.reshape(H[:,n,:,:,j],(self.M,self.K*self.L),'F')
        
                #Extract channel realizations from all UEs to BS j
                Hhatallj = np.reshape(Hhat[:,n,:,:,j],(self.M,self.K*self.L),'F')
        
                #Compute MR combining in (4.11)
                V_MR = Hhatallj[:,self.K*j:self.K*(j+1)]
                #print('AK', V_MR)
        
                #Compute M-MMSE combining in (4.7)
                #Backslash or matrix left division. If A is a square matrix, A\B is roughly the same as inv(A)*B, except it is computed in a different way
                tempM = self.p*(self.p*(np.matmul(Hhatallj,np.conj(np.transpose(Hhatallj)))) + C_totM[:,:,j]+eyeM)
                V_MMMSE = np.matmul(np.linalg.inv(tempM), V_MR)
                #Go through all UEs in cell j
                for k in range(self.K):
                    if np.linalg.norm(V_MR[:,k])>0:
                        #M-MMSE precoding
                        w = V_MMMSE[:,k]/np.linalg.norm(V_MMMSE[:,k]) #Extract precoding vector
                        w = np.reshape(w,(1,self.M)).conj() #Hermitian: make it a row vector and conjugate

                        #Compute realizations of the terms inside the expectations
                        #of the signal and Bernoulli_extra_interference terms of (7.2) and (7.3)
                        h_temp = H[:,n,k,j,j]
                        signal_MMMSE[k,j] = signal_MMMSE[k,j] + (np.inner(w,h_temp))/self.nbrOfRealizations
                        h_temp = np.matmul(w,Hallj)
                        h_temp = np.abs(np.array(h_temp))**2
                        h_temp = np.reshape(h_temp,(self.K,self.L),'F')

                        #print('AK', np.max(h_temp[:]))

                        interf_MMMSE[k,j,:,:] = interf_MMMSE[k,j,:,:] + h_temp/self.nbrOfRealizations
        #Compute the terms in (7.2)
        signal_MMMSE = np.abs(signal_MMMSE)**2
        #print('AK2', signal_MMMSE)
        #Compute the terms in (7.3)
        for j in range(self.L):
            for k in range(self.K):
                interf_MMMSE[k,j,k,j] = interf_MMMSE[k,j,k,j] - signal_MMMSE[k,j]
        return signal_MMMSE, interf_MMMSE

    '''
    from functionComputeSINR_DL.m
    Implements only the MR precoding (from MR combining and duality)
    '''
    def compute_SINR_DL_mr_precoding(self, H, Hhat, C):
        if False:
            #fileName = 'D:/gits/lasse/software/mimo-toolbox/third_party/emil_massivemimobook/Code/H_Hhat_C.mat'
            fileName = '/mnt/d/gits/lasse/software/mimo-toolbox/third_party/emil_massivemimobook/Code/H_Hhat_C.mat'
            H=read_matlab_array_from_mat(fileName, 'H')
            Hhat=read_matlab_array_from_mat(fileName, 'Hhat')
            C=read_matlab_array_from_mat(fileName, 'C')

        #Store identity matrices of different sizes
        #eyeK = np.eye(self.K)
        #eyeM = np.eye(self.M)

        #Compute sum of all estimation error correlation matrices at every BS
        #C_totM = np.reshape(self.p*np.sum(np.sum(C,2),2),[self.M, self.M, self.L],'F')

        #Compute the prelog factor assuming only downlink transmission
        #prelogFactor = (self.tau_c-self.tau_p)/(self.tau_c)

        #Prepare to store simulation results for signal gains
        signal_MR = np.zeros((self.K,self.L),dtype=np.complex64)

        #Prepare to store simulation results for Bernoulli_extra_interference powers
        #interf_MMMSE = np.zeros((self.K,self.L,self.K,self.L),dtype=np.complex64)
        interf_MR = np.zeros((self.K,self.L,self.K,self.L)) #real-valued, not complex

        for n in range(self.nbrOfRealizations): #Go through all channel realizations
            #Go through all cells
            for j in range(self.L):
                #Extract channel realizations from all UEs to BS j
                Hallj = np.reshape(H[:,n,:,:,j],(self.M,self.K*self.L),'F')

                #Extract channel realizations from all UEs to BS j
                Hhatallj = np.reshape(Hhat[:,n,:,:,j],(self.M,self.K*self.L),'F')

                #Compute MR combining in (4.11)
                V_MR = Hhatallj[:,self.K*j:self.K*(j+1)]
                #print('AK', V_MR)

                #Compute M-MMSE combining in (4.7)
                #Backslash or matrix left division. If A is a square matrix, A\B is roughly the same as inv(A)*B, except it is computed in a different way
                #tempM = self.p*(self.p*(np.matmul(Hhatallj,np.conj(np.transpose(Hhatallj)))) + C_totM[:,:,j]+eyeM)
                #V_MMMSE = np.matmul(np.linalg.inv(tempM), V_MR)
                #Go through all UEs in cell j
                for k in range(self.K):
                    if np.linalg.norm(V_MR[:,k])>0:
                        #MR precoding
                        w = V_MR[:,k]/np.linalg.norm(V_MR[:,k]) #Extract precoding vector
                        w = np.reshape(w,(1,self.M)).conj() #Hermitian: make it a row vector and conjugate

                        #Compute realizations of the terms inside the expectations
                        #of the signal and Bernoulli_extra_interference terms of (7.2) and (7.3)
                        h_temp = H[:,n,k,j,j]
                        signal_MR[k,j] = signal_MR[k,j] + (np.inner(w,h_temp))/self.nbrOfRealizations
                        h_temp = np.matmul(w,Hallj)
                        h_temp = np.abs(np.array(h_temp))**2
                        h_temp = np.reshape(h_temp,(self.K,self.L),'F')

                        #print('AK', np.max(h_temp[:]))

                        interf_MR[k,j,:,:] = interf_MR[k,j,:,:] + h_temp/self.nbrOfRealizations
        #Compute the terms in (7.2)
        signal_MR = np.abs(signal_MR)**2
        #print('AK2', signal_MR)
        #Compute the terms in (7.3)
        for j in range(self.L):
            for k in range(self.K):
                interf_MR[k,j,k,j] = interf_MR[k,j,k,j] - signal_MR[k,j]
        return signal_MR, interf_MR


    '''
    from functionComputeSINR_DL.m
    Implements only the RZF precoding (from RZF combining and duality)
    '''
    def compute_SINR_DL_rzf_precoding(self, H, Hhat, C):
        if False:
            #fileName = 'D:/gits/lasse/software/mimo-toolbox/third_party/emil_massivemimobook/Code/H_Hhat_C.mat'
            fileName = '/mnt/d/gits/lasse/software/mimo-toolbox/third_party/emil_massivemimobook/Code/H_Hhat_C.mat'
            H=read_matlab_array_from_mat(fileName, 'H')
            Hhat=read_matlab_array_from_mat(fileName, 'Hhat')
            C=read_matlab_array_from_mat(fileName, 'C')

        #Store identity matrices of different sizes
        eyeK = np.eye(self.K)
        #eyeM = np.eye(self.M)

        #Compute sum of all estimation error correlation matrices at every BS
        #C_totM = np.reshape(self.p*np.sum(np.sum(C,2),2),[self.M, self.M, self.L],'F')

        #Compute the prelog factor assuming only downlink transmission
        #prelogFactor = (self.tau_c-self.tau_p)/(self.tau_c)

        #Prepare to store simulation results for signal gains
        signal_RZF = np.zeros((self.K,self.L),dtype=np.complex64)

        #Prepare to store simulation results for Bernoulli_extra_interference powers
        interf_RZF = np.zeros((self.K,self.L,self.K,self.L)) #real-valued, not complex

        for n in range(self.nbrOfRealizations): #Go through all channel realizations
            #Go through all cells
            for j in range(self.L):
                #Extract channel realizations from all UEs to BS j
                Hallj = np.reshape(H[:,n,:,:,j],(self.M,self.K*self.L),'F')

                #Extract channel realizations from all UEs to BS j
                Hhatallj = np.reshape(Hhat[:,n,:,:,j],(self.M,self.K*self.L),'F')

                #Compute MR combining in (4.11)
                V_MR = Hhatallj[:,self.K*j:self.K*(j+1)]
                #print('AK', V_MR)

                #Compute M-MMSE combining in (4.7)
                #Backslash or matrix left division. If A is a square matrix, A\B is roughly the same as inv(A)*B, except it is computed in a different way
                #tempM = self.p*(self.p*(np.matmul(Hhatallj,np.conj(np.transpose(Hhatallj)))) + C_totM[:,:,j]+eyeM)
                #V_MMMSE = np.matmul(np.linalg.inv(tempM), V_MR)
                #Go through all UEs in cell j

                #Compute RZF combining in (4.9)
                #V_RZF = p*V_MR/(p*(V_MR'*V_MR)+eyeK);
                temp = self.p*np.matmul(np.matrix(V_MR).getH(), V_MR) + eyeK
                temp = np.linalg.inv(temp)
                V_RZF = np.matmul(self.p * V_MR, temp)

                for k in range(self.K):
                    if np.linalg.norm(V_MR[:,k])>0:
                        #RZF precoding
                        w = V_RZF[:,k]/np.linalg.norm(V_RZF[:,k]) #Extract precoding vector
                        w = np.reshape(w,(1,self.M)).conj() #Hermitian: make it a row vector and conjugate

                        #Compute realizations of the terms inside the expectations
                        #of the signal and Bernoulli_extra_interference terms of (7.2) and (7.3)
                        h_temp = H[:,n,k,j,j]
                        signal_RZF[k,j] = signal_RZF[k,j] + (np.inner(w,h_temp))/self.nbrOfRealizations
                        h_temp = np.matmul(w,Hallj)
                        h_temp = np.abs(np.array(h_temp))**2
                        h_temp = np.reshape(h_temp,(self.K,self.L),'F')

                        #print('AK', np.max(h_temp[:]))

                        interf_RZF[k,j,:,:] = interf_RZF[k,j,:,:] + h_temp/self.nbrOfRealizations
        #Compute the terms in (7.2)
        signal_RZF = np.abs(signal_RZF)**2
        #print('AK2', signal_RZF)
        #Compute the terms in (7.3)
        for j in range(self.L):
            for k in range(self.K):
                interf_RZF[k,j,k,j] = interf_RZF[k,j,k,j] - signal_RZF[k,j]
        return signal_RZF, interf_RZF


    '''
    %INPUT:
    %rho          = K x L matrix where element (k,j) is the downlink transmit
    %               power allocated to UE k in cell j
    %signal       = K x L matrix where element (k,j,n) is a_jk in (7.2)
    %Bernoulli_extra_interference = K x L x K x L matrix where (l,i,jk,n) is b_lijk in (7.3)
    %prelogFactor = Prelog factor
    %
    %OUTPUT:
    %SE = K x L matrix where element (k,j) is the downlink SE of UE k in cell j
    %     using the power allocation given as input
    '''
    def computeSE_DL_poweralloc(self, rho, signal, interference):
        #Compute the prelog factor assuming only downlink transmission
        prelogFactor = (self.tau_c-self.tau_p)/(self.tau_c)
        #Prepare to save results
        SE = np.zeros((self.K,self.L))
        # Go through all cells
        for j in range(self.L):
            #Go through all UEs in cell j
            for k in range(self.K):
                #Compute the SE in Theorem 4.6 using the formulation in (7.1)
                SE[k,j] = prelogFactor*np.log2(1+(rho[k,j]*signal[k,j]) / (sum(sum(rho*interference[:,:,k,j])) + 1))
        return SE


'''
Look at  
D:\gits\lasse\software\mimo-toolbox\third_party\emil_massivemimobook\Code\ak_functionExampleSetup.m
'''
def test_estimation():
    #saved with save -v6 R_channelGaindB R channelGaindB
    fileName = 'D:/gits/lasse/software/mimo-toolbox/third_party/emil_massivemimobook/Code/R_channelGaindB.mat'
    arrayName = 'channelGaindB'
    x=read_matlab_array_from_mat(fileName, arrayName)
    R=read_matlab_array_from_mat(fileName, 'R')
    #Matlab: ak_receivedSignal_y(10,5,20)
    print(x[9,4,9])
    print(R[3,4,3,0,1])

if __name__ == '__main__':
    #https://stackoverflow.com/questions/38461588/achieve-same-random-numbers-in-numpy-as-matlab
    np.random.seed(1)

    #test_estimation()
    ce = ChannelEstimator()
    H = ce.channel_realizations()

    #print('min H', np.min(np.abs(H)))

    Hhat_MMSE, C_MMSE = ce.channel_estimates_mmse(H)

    if should_compare_with_Matlab:
        #debug1:     save -v6 debug1 Hhat C H
        if os.name == 'nt':
            fileName = 'D:/gits/lasse/software/mimo-toolbox/third_party/emil_massivemimobook/Code/debug1.mat'
        else:
            fileName = '/mnt/d/gits/lasse/software/mimo-toolbox/third_party/emil_massivemimobook/Code/debug1.mat'
        mat_Hhat=read_matlab_array_from_mat(fileName, 'Hhat')
        mat_C=read_matlab_array_from_mat(fileName, 'C')
        mat_H=read_matlab_array_from_mat(fileName, 'H')

        print('error H = ', compare_tensors(H,mat_H))
        print('error Hhat = ', compare_tensors(Hhat_MMSE,mat_Hhat))
        print('error C = ', compare_tensors(C_MMSE,mat_C))

    #print('after')
    #print(Hhat_MMSE[:,:,0,0,0])
    #print(C_MMSE[:,:,0,0,0])
    signal_MMMSE, interf_MMMSE = ce.compute_SINR_DL_mmse_precoding(H, Hhat_MMSE, C_MMSE)
    signal_MR, interf_MR = ce.compute_SINR_DL_mr_precoding(H, Hhat_MMSE, C_MMSE)
    signal_RZF, interf_RZF = ce.compute_SINR_DL_rzf_precoding(H, Hhat_MMSE, C_MMSE)
    print('max(interf_MMMSE)', np.max(interf_MMMSE[:]))
    print('min(interf_MMMSE)', np.min(interf_MMMSE[:]))

    SE_MMSE = ce.computeSE_DL_poweralloc(ce.rhoEqual, signal_MMMSE, interf_MMMSE)
    SE_MR = ce.computeSE_DL_poweralloc(ce.rhoEqual, signal_MR, interf_MR)
    SE_RZF = ce.computeSE_DL_poweralloc(ce.rhoEqual, signal_RZF, interf_RZF)
    #print('SE=', SE_MMSE)

    if should_compare_with_Matlab:
        #save -v6 debug2 SE_MR_equal SE_RZF_equal SE_MMMSE_equal
        if os.name == 'nt':
            fileName = 'D:/gits/lasse/software/mimo-toolbox/third_party/emil_massivemimobook/Code/debug2.mat'
        else:
            fileName = '/mnt/d/gits/lasse/software/mimo-toolbox/third_party/emil_massivemimobook/Code/debug2.mat'
        SE_MR_equal=read_matlab_array_from_mat(fileName, 'SE_MR_equal')
        SE_RZF_equal=read_matlab_array_from_mat(fileName, 'SE_RZF_equal')
        SE_MMMSE_equal=read_matlab_array_from_mat(fileName, 'SE_MMMSE_equal')

        print('error SE_RZF_equal = ', compare_tensors(SE_RZF,SE_RZF_equal))
        print('error SE_MR_equal = ', compare_tensors(SE_MR,SE_MR_equal))
        print('error SE_MMMSE_equal = ', compare_tensors(SE_MMSE,SE_MMMSE_equal))

    #plt.plot(sort(SE_MMMSE_equal(:)),linspace(0,1,K*L*nbrOfSetups),'r','LineWidth',1)
    SE_MMSE_vector = SE_MMSE.flatten()
    SE_MR_vector = SE_MR.flatten()
    SE_RZF_vector = SE_RZF.flatten()


    plt.plot(np.sort(SE_MR_vector),np.linspace(0,1,ce.K * ce.L),'-k',label='MR')
    plt.plot(np.sort(SE_RZF_vector),np.linspace(0,1,ce.K * ce.L),'-b',label='RZF')
    plt.plot(np.sort(SE_MMSE_vector),np.linspace(0,1,ce.K * ce.L),'-r',label='MMSE')
    #plt.legend('MR','RZF','MMSE')
    plt.legend(loc='upper left')
    plt.xlabel('SE per UE [bit/s/Hz]')
    plt.ylabel('CDF')
    plt.axis([0,7,0,1])
    plt.show()

